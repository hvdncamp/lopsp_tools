/*
Copyright 2023 Heidi Van den Camp

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
A copy of the License is included in the repository and you can also
view it at
        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
  Reads lsp-operations in decocode as generated by decogen (https://github.com/314eter/decogen)
  and outputs the corresponding lopsp-operations in lopsp-format.
  Input is taken from stdin and output is given through stdout.
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include"lib/lopsp_functions.h"
#include"lib/graph_io.h"

void glue_mirror_copy(Edge** original, Edge** new_edges, Graph* graph, const int* mirror_vertices, const int* mirror_side){
    Edge* new_edge;
    Edge* original_edge;
    int mirror_name[graph->vertexcount + 1];
    int new_vertexcount = graph->vertexcount;
    int original_edgecount = graph->edgecount;

    for (int i = 1; i <= graph->vertexcount; ++i) {
        if (mirror_vertices[i]){
            mirror_name[i] = i;
        } else {
            new_vertexcount++;
            mirror_name[i] = new_vertexcount;
        }
    }

    for (int index = 0; index < original_edgecount; ++index) {
        if(original[index]->type == 3){
            new_edges[index] = get_edge(mirror_name[original[index]->start], graph);
            graph->edges[mirror_name[original[index]->start]] = new_edges[index];
        } else {
            new_edges[index] = original[index];
        }
        //the other edges must be preserved, they are on the boundary
    }

    for (int index = 0; index < original_edgecount; ++index) {
        new_edge = new_edges[index];
        original_edge = original[index];

        if (new_edge != original_edge){//set inverse for new edges
            new_edge->inverse = new_edges[original_edge->inverse->unique_number];
            new_edge->end = new_edge->inverse->start;
        }

        if (mirror_side[original_edge->unique_number] % 2 == 1){ // mirror on left of original
            if (original_edge->type != 1){
                make_next(new_edge, original_edge);
            }
        } else {
            new_edge->next = new_edges[original_edge->prev->unique_number];
        }

        if (mirror_side[original_edge->unique_number] > 1){ // mirror on right of original
            if (original_edge->type != 2){
                make_next(original_edge, new_edge);// the original edge is not looped over, so its value must be set here
            }
        } else {
            new_edge->prev = new_edges[original_edge->next->unique_number];
        }
    }
    graph->vertexcount = new_vertexcount;
}

void make_edge_array(Graph* graph, Edge** array){
    Edge* edge;
    for (int i = 1; i <= graph->vertexcount; ++i) {
        edge = graph->edges[i];
        do {
            array[edge->unique_number] = edge;
            edge = edge->next;
        } while (edge != graph->edges[i]);
    }
}

Edge* find_edge(int startv, int endv, Graph* graph){
    Edge* edge = graph->edges[startv];
    do {
        if (edge->end == endv){
            return edge;
        }
        edge = edge->next;
    } while (edge != graph->edges[startv]);
    return NULL;
}

void interpret_border(int kind, uint8_t a, uint8_t b, uint16_t * v0, uint16_t * v1, uint16_t * v2, Graph* lopsp,
                      const uint8_t* border_type, int* border_vertices, Edge** border_start_edge, int* mirror_side){
    Edge* edge;
    Edge* v1edge;
    Edge* v1inverse;
    int index;

    edge = find_edge(a, b, lopsp);

    if (kind == 0 || kind == 1){
        //add new vertex v1 at vertex of type 0
        if (kind == 0){
            mirror_side[edge->unique_number] = 2;
            edge = edge->inverse->prev;
        } else {
            mirror_side[edge->inverse->unique_number] = 1;
        }
        *v1 = lopsp->vertexcount + 1;
        v1edge = get_edge(*v1, lopsp);
        v1inverse = get_edge(edge->start, lopsp);
        make_inverse(v1edge, v1inverse);

        v1edge->next = v1edge->prev = v1edge;
        insert_after(edge, v1inverse);

        v1edge->type = (kind == 0) ? 2 : 1;
        v1inverse->type = (kind == 0) ? 1 : 2;

        if (kind == 0) {
            mirror_side[v1edge->unique_number] = 3;
            mirror_side[v1inverse->unique_number] = 1;
        } else {
            mirror_side[v1edge->unique_number] = 3;
            mirror_side[v1inverse->unique_number] = 2;
        }

        set_vertexcount(lopsp, lopsp->vertexcount + 1);
        lopsp->edges[lopsp->vertexcount] = v1edge;

        if (kind == 0){
            *border_start_edge = v1inverse->next->inverse->next;
        } else {
            *border_start_edge = v1inverse->next;
        }
    } else {
        *border_start_edge = edge->next;
    }

    //fill boundary vertices and determine v0, v1, v2
    index = 0;
    edge = *border_start_edge; //now edge is an edge of the outer face
    border_vertices[edge->start]++;
    while (border_type[index] != 0){
        if (border_type[index] == 1){
            //this edge is in the border
            edge->type = 1;
            edge->inverse->type = 2;
            mirror_side[edge->unique_number] += 1;
            mirror_side[edge->inverse->unique_number] += 2;
            edge = edge->inverse->next;
        } else if(border_type[index] == 2){
            mirror_side[edge->unique_number] += 1;
            edge = edge->inverse->next;
            mirror_side[edge->inverse->unique_number] += 2;
            edge = edge->inverse->next;
        }
        border_vertices[edge->start]++;
        index++;
    }
    //v2
    *v2 = edge->start;

    index++;
    while (border_type[index] != 0){
        if (border_type[index] == 1){
            //this edge is in the border
            edge->type = 1;
            edge->inverse->type = 2;
            mirror_side[edge->unique_number] += 1;
            mirror_side[edge->inverse->unique_number] += 2;
            edge = edge->inverse->next;
        } else if(border_type[index] == 2){
            mirror_side[edge->unique_number] += 1;
            edge = edge->inverse->next;
            mirror_side[edge->inverse->unique_number] += 2;
            edge = edge->inverse->next;
        }
        border_vertices[edge->start]++;
        index++;    }
    //v0
    *v0 = edge->start;

    index++;
    while (border_type[index] != 0){
        if (border_type[index] == 1){
            //this edge is in the border
            edge->type = 1;
            edge->inverse->type = 2;
            mirror_side[edge->unique_number] += 1;
            mirror_side[edge->inverse->unique_number] += 2;
            edge = edge->inverse->next;
        } else if(border_type[index] == 2){
            mirror_side[edge->unique_number] += 1;
            edge = edge->inverse->next;
            mirror_side[edge->inverse->unique_number] += 2;
            edge = edge->inverse->next;
        }
        border_vertices[edge->start]++;
        index++;
    }
    //v1
    if(kind == 2 || kind == 3) {*v1 = edge->start;}
    else {
        border_vertices[*v1]++;
    }
}

int main(int argc,char *argv[]) {
    Graph *lopsp = new_graph(20);
    init_graph(lopsp);
    uint8_t kind;
    uint8_t a,b;
    uint16_t v0, v1, v2, v1type1;
    uint16_t type_start;
    uint16_t print_number;
    Edge *temp;
    int border_length;
    int count0;
    uint16_t zero = 0;
    Edge *border_start_edge; //the first edge of the border
    int lspcount = 0;

    init_edges();

    //Read and check header
    char buffer[14];
    if(fgets(buffer, 14, stdin) == NULL){
        fprintf(stderr, "The encoding of the operations should start with the header >>deco_code<< \n");
        exit(1);
    }
    if (strcmp(buffer, ">>deco_code<<") != 0) {
        fprintf(stderr, "The encoding of the operations should start with the header >>deco_code<< \n");
        exit(1);
    }

    fputs(">>lopsp<<", stdout);

    while(read_planarcode(stdin, lopsp, PLANAR_CODE_LITTLE_ENDIAN)) {
        //read kind and a and b
        lspcount++;
        if(fread(&kind, 1, 1, stdin) != 1 ){
            fprintf(stderr, "Decocode number %d could not be read. Are you sure it is encoded correctly?\n", lspcount);
            exit(1);
        }
        switch (kind) {
            case 0:
            case 1:
                v1type1 = 1;
                break;
            case 2:
            case 3:
                v1type1 = 0;
                break;
            default:
                fprintf(stderr, "kind should be 0, 1, 2 or 3, not %d\n", kind);
                exit(1);
        }
        if(fread(&a, 1, 1, stdin) != 1 ){
            fprintf(stderr, "Decocode number %d could not be read. Are you sure it is encoded correctly?\n", lspcount);
            exit(1);
        }
        if(fread(&b, 1, 1, stdin) != 1 ){
            fprintf(stderr, "Decocode number %d could not be read. Are you sure it is encoded correctly?\n", lspcount);
            exit(1);
        }

        //read border
        int border_vertices[lopsp->vertexcount + 2];//true if a vertex is in the border
        int mirror_side[lopsp->edgecount + 2];//at most two edges are added

        uint8_t border_type[lopsp->vertexcount + 5];
        border_length = 0;

        for (int i = 0; i < lopsp->vertexcount + 2; ++i) {
            border_vertices[i] = 0;
        }
        for (int i = 0; i < lopsp->edgecount + 2; ++i) {
            mirror_side[i] = 0;
        }

        count0 = 0;
        while (count0 < 3) {
            if(fread(border_type + border_length, 1, 1, stdin) != 1){
                fprintf(stderr, "Decocode number %d could not be read. Are you sure it is encoded correctly?\n", lspcount);
                exit(1);
            }
            if (border_type[border_length] == 0) {
                count0++;
            }
            border_length++;
        }

        interpret_border(kind, a, b , &v0, &v1, &v2, lopsp, border_type, border_vertices, &border_start_edge, mirror_side);

        if (v1type1){
            type_start = kind == 0 ? 2 : 0;
        } else {
            type_start = kind == 2 ? 2 : 0; // 0 or 2, the type of v1
        }
        while (border_start_edge->start != v0){
            border_start_edge = border_start_edge->inverse->next;
            type_start = 2 - type_start;
        }
        //now type_start is the type of v0

        //mirror copy and glue
        Edge *edge_array[lopsp->edgecount];
        make_edge_array(lopsp, edge_array);
        Edge *mirror_edges[lopsp->edgecount]; //mirror_edges[i] is the edge that corresponds to the edge with number i
        glue_mirror_copy(edge_array, mirror_edges, lopsp, border_vertices, mirror_side);

        fwrite(&lopsp->vertexcount, sizeof(uint16_t), 1, stdout);
        fwrite(&v0, sizeof(uint16_t), 1, stdout);
        fwrite(&v1, sizeof(uint16_t), 1, stdout);
        fwrite(&v2, sizeof(uint16_t), 1, stdout);
        fwrite(&type_start, sizeof(uint16_t), 1, stdout);
        fwrite(&v1type1, sizeof(uint16_t), 1, stdout);

        int edge_number[lopsp->edgecount]; //to mark edges that have been seen
        for (int i = 0; i < lopsp->edgecount; ++i) {
            edge_number[i] = -1;
        }
        print_number = 1;
        for (int i = 1; i <= lopsp->vertexcount; ++i) {
            temp = lopsp->edges[i];
            do {
                if (edge_number[temp->unique_number] == -1){//not seen before
                    edge_number[temp->unique_number] = print_number;
                    edge_number[temp->inverse->unique_number] = print_number;
                    print_number++;
                }
                fwrite(&edge_number[temp->unique_number], sizeof(uint16_t), 1, stdout);
                temp = temp->next;
            } while ( temp != lopsp->edges[i]);
            fwrite(&zero, sizeof(uint16_t), 1, stdout);
        }
        init_graph(lopsp);
    }
    fprintf(stderr, "%d lsp-operations read and converted to lopsp-operations\n", lspcount);
    free_graph(lopsp);
}
